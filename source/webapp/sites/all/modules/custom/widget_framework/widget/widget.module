<?php
/**
* This file is part of the Checkbook NYC financial transparency software.
*
* Copyright (C) 2012, 2013 New York City
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License as
* published by the Free Software Foundation, either version 3 of the
* License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Affero General Public License for more details.
*
* You should have received a copy of the GNU Affero General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


$module_data_controller_path = realpath(drupal_get_path('module', 'data_controller'));

require_once($module_data_controller_path . '/common/pattern/AbstractObject.php');
require_once($module_data_controller_path . '/common/object/comparator/Comparator.php');
require_once($module_data_controller_path . '/common/object/comparator/handler/AbstractComparator.php');
require_once($module_data_controller_path . '/common/object/comparator/handler/AbstractValueComparator.php');
require_once($module_data_controller_path . '/common/object/comparator/handler/PropertyBasedComparator.php');
require_once($module_data_controller_path . '/common/object/comparator/handler/DefaultPropertyBasedComparator.php');
require_once($module_data_controller_path . '/common/object/exception/UnsupportedOperationException.php');
require_once($module_data_controller_path . '/datasource/formatter/ResultFormatter.php');
require_once($module_data_controller_path . '/datasource/formatter/handler/SpecialCharacterResultFormatter.php');
require_once($module_data_controller_path .'/common/object/converter/DataConverter.php');
require_once($module_data_controller_path .'/common/object/converter/handler/AbstractDataConverter.php');
require_once($module_data_controller_path .'/common/object/converter/handler/AbstractJson2PHP.php');
require_once($module_data_controller_path .'/common/object/converter/handler/PHP2Json.php');
require_once($module_data_controller_path .'/common/object/converter/handler/AbstractJson2PHP.php');
require_once($module_data_controller_path .'/common/object/converter/handler/Json2PHP.php');

/***************************************/
/* Implementation of Widget Node Type  */
/***************************************/

function widget_menu(){
  $items['widget_ajax_data/node/%widget/%'] = array(
      'page callback' => 'widget_ajax_get_node',
      'page arguments' => array(2),
      'access callback' => true,
      'type'=>MENU_CALLBACK
  );

  $items['widget/%'] = array(
  		'page callback' => '_widget_node_view_page',
  		'page arguments' => array(1),
  		'access callback' => true,
  		'type'=>MENU_CALLBACK
  );

  return $items;
}

function widget_load($key){
  $node = _widget_node_load_file($key);
  return $node;
}

function _widget_node_load($key, $type='node'){
	if(preg_match("/^admin/",$_GET['q'])){
		return "";
	}

	switch ($type) {
		case 'node':
			return node_load($key);
		case 'file':
			return _widget_node_load_file($key);
	}
	return FALSE;
}

function _widget_node_view_page($key){
	$node = _widget_node_load_file($key);
	$node = widget_node_view($node);
	return $node->content['body']['#markup'];
}


function _widget_node_view($key){
	$node = _widget_node_load_file($key);
	$node = widget_node_view($node);
	echo $node->content['body']['#markup'];
}

function _widget_node_load_file($key){
	$node =  new stdClass();
	$node->type = "widget";

  $files = file_scan_directory( drupal_get_path('module','widget_config') , '/^'.$key.'\.json$/');
  if(count($files) > 0){
    $file_names = array_keys($files);
    $json = file_get_contents($file_names[0]);
    $node->widget_json =  $json;
  }

  if($node->nid == null){
    $node->nid = $key;
  }
  return $node;
}

function widget_node_load($nodes,$types){
	if(preg_match("/^admin/",$_GET['q'])){
		return "";
	}

  foreach($nodes as $nid => $node ){
    if( $node->type == "widget"){
      $files = file_scan_directory(drupal_get_path('module', 'widget_config'), '/^' . $nid . '\.json$/');
      if (count($files) > 0) {
        $file_names = array_keys($files);
        $json = file_get_contents($file_names[0]);
        $node->widget_json = $json;
      } else {
        $node->widget_json = $node->body['und'][0]['value'];
      }
    }
  }
  return FALSE;
}

function widget_node_validate(&$node) {
	if($node->type != 'widget') {
    return;
  }
	widget_config($node);
  return;
}

function widget_node_view($node, $nodata = true) {
	if($node->type != 'widget') {
    return FALSE;
  }

	//make sure configuration is loaded
	widget_config($node);

	//prepare anything we'll need before loading
	widget_prepare($node);

	//invoke widget specific prepare
	widget_invoke($node, 'widget_prepare');

	//load data
	if(($node->widgetConfig->noDataInitialLoad == null || !$node->widgetConfig->noDataInitialLoad) || !$nodata ){
    widget_data($node);
	}

	if (isset($node->error)) {
		//dont call the specific module. Display generic error message and return
		//message needs to be set on the widget configuration. not hardcoded.
		$errorMsg = 'There was an error processing your request. Please try again in a few minutes.';
		$node->content['body'] = array('#value' => $errorMsg, '#weight' => 0,);
		return $node;
	}
		//invoke widget specific post-load function
	if(isset($node->widgetConfig->widgetUpdateJSONConfig)){
		if($node->widgetConfig->widgetType == 'highcharts'){

		  if (!isset($node->widgetConfig->chartConfig->chart)) {
        $node->widgetConfig->chartConfig->chart = new stdClass();
      }

      if (!isset($node->widgetConfig->chartConfig->credits)) {
        $node->widgetConfig->chartConfig->credits = new stdClass();
      }

			$node->widgetConfig->chartConfig->chart->renderTo = 'node-chart-' . widget_unique_identifier($node);
			$node->widgetConfig->chartConfig->credits->enabled = false;
		}
		@eval($node->widgetConfig->widgetUpdateJSONConfig);
	}else{
		widget_invoke($node, 'widget_data');
	}

	if ($node->widgetConfig->dataOnly) {
		$node->content['body'] = array(
			'#value' => $node->data,
			'#weight' => 0,
		);
	}
	else {
		$val = widget_invoke($node, 'widget_view');
		$node->content['body'] = array(
			'#markup' => $val,
			'#weight' => 0,
		);
	}
	return $node;
}

/***************************************/
/* Introduction of Widget Hooks        */
/***************************************/

function widget_hook(&$node, $hook) {
	$module = widget_get_types('module', $node);
	if ($module == 'widget') {
		$module = 'widget_content'; // Avoid function name collisions.
	}
	return module_hook($module, $hook);
}

function widget_invoke(&$node, $hook, $a2 = NULL, $a3 = NULL, $a4 = NULL) {
	if (widget_hook($node, $hook)) {
		$module = widget_get_types('module', $node);
		if ($module == 'widget') {
			$module = 'widget_content'; // Avoid function name collisions.
		}
		$function = $module .'_'. $hook;
		return ($function($node, $a2, $a3, $a4));
	}
	return FALSE;
}

function widget_get_types($op = 'types', $node = NULL, $reset = FALSE) {
	static $_widget_types, $_widget_names;

	if ($reset || !isset($_widget_types)) {
		[$_widget_types, $_widget_names] = _widget_types_build();
	}

  $type = null;
	if ($node) {
		if (is_object($node)) {
			$type = $node->widgetConfig->widgetType;
		}
		if (!isset($_widget_types[$type])) {
			return FALSE;
		}
	}
	switch ($op) {
		case 'types':
			return $_widget_types;
		case 'type':
			return isset($_widget_types[$type]) ? $_widget_types[$type] : FALSE;
		case 'module':
			return isset($_widget_types[$type]->module) ? $_widget_types[$type]->module : FALSE;
		case 'names':
			return $_widget_names;
		case 'name':
			return isset($_widget_names[$type]) ? $_widget_names[$type] : FALSE;
	}
	return FALSE;
}

function _widget_types_build() {
	$_widget_types = array();
	$_widget_names = array();

	$info_array = module_invoke_all('widget_metadata');
	///drupal_set_message('<pre>$info_array'. print_r($info_array, TRUE) . '</pre>');
	foreach ($info_array as $type => $info) {
		$info['type'] = $type;
		$_widget_types[$type] = (object) _widget_type_set_defaults($info);
		$_widget_names[$type] = $info['name'];
	}

	asort($_widget_names);
	return array($_widget_types, $_widget_names);
}

function _widget_type_set_defaults($info) {
	//currently we have no default values to set
	return $info;
}

/***************************************/
/* Default Implementation of Core      */
/***************************************/

function widget_prepare(&$node) {
	//filter all the request variables
	foreach ($_REQUEST as $key => $val) {
		$_REQUEST[$key] = $val;
	}

	if (isset($_REQUEST['data'])) {
		$node->widgetConfig->dataOnly = TRUE;
	}

	if(isset($node->widgetConfig->widgetPreprocessJSON)){
		eval($node->widgetConfig->widgetPreprocessJSON);
	}

	//copy request params and apply default and additional params
	//$node->widgetConfig->requestParams = $_REQUEST;
	if (isset($node->widgetConfig->cleanURLParameters)) {
		$urlParams = $node->widgetConfig->cleanURLParameters;
		$urlPath = drupal_get_path_alias($_GET['q']);
		$pathParams = explode('/', $urlPath);

		for($i = 0; $i < count($pathParams); $i = $i + 1) {
			foreach ($urlParams as $up) {
                $pathParam = $pathParams[$i];
				if ($up == $pathParams[$i]) {
          $up = isset($node->widgetConfig->urlParamMap) ? $node->widgetConfig->urlParamMap->$up : $up;
					if(isset($pathParams[$i + 1]) && $pathParams[$i + 1] !='all'){
              $pathParams[$i + 1] = _replaceSpecialCharactersDecode($pathParams[$i + 1]);
              $node->widgetConfig->requestParams[$up] = htmlspecialchars_decode($pathParams[$i + 1]);
              $node->widgetConfig->originalRequestParams[$pathParam] = htmlspecialchars_decode($pathParams[$i + 1]);
          }
					break;
				}
			}
		}

    if(isset($node->widgetConfig->allowRequestParams)){
        foreach($node->widgetConfig->allowRequestParams as $param){
            $index = array_search($param,$pathParams);
            if( $index !== FALSE && ($pathParams[($index + 1)] != '') ){
                $node->widgetConfig->allowRequestParamValues[$param] = $pathParams[($index + 1)];
            }
        }
    }
	}

  if(isset($node->widgetConfig->urlParamMap) && is_array(get_object_vars($node->widgetConfig->urlParamMap))){
    foreach($node->widgetConfig->urlParamMap as $key=>$value){
      if(!isset($node->widgetConfig->originalRequestParams[$key])){
        unset($node->widgetConfig->urlParamMap->$key);
      }
    }
  }
    prepare_dataset_parameters($node->widgetConfig->requestParams, $node->widgetConfig);

    if(isset($node->widgetConfig->preProcessConfiguration)){
    	$parameters =  eval($node->widgetConfig->preProcessConfiguration);
    }

    if (is_array($node->widgetConfig->model->series)) {
      foreach ($node->widgetConfig->model->series as $series) {
        if(isset($series->preProcessConfiguration)){
          $parameters =  eval($series->preProcessConfiguration);
        }
      }
    }
}

function prepare_dataset_parameters(&$requestParameters, $configuration,$widgetConfig = null) {
  // remove excluded params
    if (isset($configuration->excludeParams)) {
      foreach ($configuration->excludeParams as $param) {
        if (isset($requestParameters[$param])) {
          unset($requestParameters[$param]);
        }
      }
    }

    if (isset($configuration->allowedParams)) {
      foreach ($requestParameters as $key => $value) {
        if (!in_array($key, $configuration->allowedParams)) {
          unset($requestParameters[$key]);
        }
      }
    }

    if (isset($configuration->defaultParameters)) {
      foreach ($configuration->defaultParameters as $key => $value) {
        if (!isset($requestParameters[$key])) {
          $key = _update_dataset_datasource($key, $configuration->keepOriginalDatasource);
          $requestParameters[$key] = $value;
        }
      }
    }

    if (isset($configuration->additionalParameters)) {
      foreach ($configuration->additionalParameters as $key => $value) {
          $key = _update_dataset_datasource($key,$configuration->keepOriginalDatasource);
          $requestParameters[$key] = $value;
      }
    }
    if(isset($configuration->seriesURLParamMap) && is_array(get_object_vars($configuration->seriesURLParamMap))){
      foreach($configuration->seriesURLParamMap as $key=>$value){
        if(!isset($widgetConfig->originalRequestParams[$key])){
          unset($configuration->seriesURLParamMap->$key);
        } else {
          if (in_array($value, $configuration->allowedParams) || !isset($configuration->allowedParams)) {
            $requestParameters[$value] = $widgetConfig->originalRequestParams[$key];
            unset($requestParameters[$key]);
          }
        }
      }
    }
}

function load_widget_data($node, $resultFormatter=null) {
  $config = $node->widgetConfig;
	if (isset($config->static_data)) {
    $node->data = $config->static_data;
    return;
  }

  $dataQueryController = data_controller_get_instance();
  try {
    // preparing default data controller parameters
    $parameters = $config->requestParams;
    if(is_array($parameters)) {
      foreach ($parameters as $key => $value) {
        if (!isset($value)) {
          unset($parameters[$key]);
          continue;
        }
        if (!is_array($value)) {
          $parameters[$key] = explode("~", $value);
        }
      }
    }

    //update
    $ajaxRequest = RequestUtilities::get('ajax');
    if(isset($config->adjustParameters)){
       @$parameters =  eval($config->adjustParameters);
    } elseif (isset($config->autocompleteField) && ('autocomplete' == $ajaxRequest)
      && isset($parameters[$config->autocompleteField]) && $parameters[$config->autocompleteField]) {
      /**
       * AUTOCOMPLETE
       */
      $autocomplete_value = $parameters[$config->autocompleteField][0];
      $parameters[$config->autocompleteField] = data_controller_get_operator_factory_instance()->initiateHandler(WildcardOperatorHandler::$OPERATOR__NAME, [
        pg_escape_string(htmlspecialchars_decode($autocomplete_value)),
        FALSE,
        TRUE,
      ]);
    }

    if(isset($config->adjustColumns)){
        $config->columns =  eval($config->adjustColumns);
    }

    $updatedParameters = array();
    if (is_array($parameters)) {
      foreach($parameters as $key=>$value){
        $key = _update_dataset_datasource($key,$node->widgetConfig->keepOriginalDatasource);
        $updatedParameters[$key] = $value;
      }
    }
    $parameters = $updatedParameters;

    //$config->logicalOrColumns
    if(isset($config->logicalOrColumns)) {
        $parameters["logicalOrColumns"] = $config->logicalOrColumns;
    }
    if(isset($config->sortSourceByNull)){
        $parameters["sortSourceByNull"]= $config->sortSourceByNull;
    }

    //if % (single or repeating) is passed as a parameter,
    //this field needs to be ignored in an ilike/like
    if(RequestUtil::isAdvancedSearchPage()) {
      foreach($parameters as $param_key => $param_value){
        if(!is_array($param_value)) continue;
        $operator_handler_class = is_object($param_value[0]) ? get_class($param_value[0]) : null;
        if($operator_handler_class == "WildcardOperatorHandler") {
          foreach($param_value[0] as $key => $value) {
            if($key == "wildcard" && preg_match("/^%*$/",$value)) {
              $data_controller_instance = data_controller_get_operator_factory_instance();
              $parameters[$param_key] = $data_controller_instance->initiateHandler(WildcardOperatorHandler::$OPERATOR__NAME,'');
              continue;
            }
          }
        }
      }
    }

    //Do not move this code before adjusting parameters.
    //Widget config may be updated.
    $isList = isset($config->useList); // FIXME v2. check for true/false
    $datasetName = _update_dataset_datasource($config->dataset,$node->widgetConfig->keepOriginalDatasource);
    $config->columns_datasource = isset($config->columns_datasource) ? $config->columns_datasource : null;
    $columns = _update_columns_by_datasource($config->columns, $config->columns_datasource,$config->keepOriginalDatasource);

    $orderBy = $config->orderBy;
    $startWith = isset($config->startWith) ? $config->startWith : 0;
    $limit = $config->limit;


    //Currently this is for list type of dataSets. For cube's more changes are required
    if($config->generateDBQuery){
       $generateDBQuery = widget_get_db_query($isList, $datasetName, $columns, $parameters, $orderBy, $startWith, $limit, $resultFormatter);
        $node->data = $generateDBQuery;
        log_debug('Generate Db Query:' . $generateDBQuery);
        return;
    }

    // FIXME v2. use 'model'-only configuration
    if (isset($config->model)) {
      $joinController = NULL;
      $joinMethod = isset($config->model->join) ? $config->model->join->method : NULL;
      $joinColumns = array();
      if(isset($config->model->join->columns)){
        $config->columns_datasource = isset($config->columns_datasource) ? $config->columns_datasource : null;
        $joinColumns = _update_columns_by_datasource($config->columns, $config->columns_datasource,$config->keepOriginalDatasource);
      }else{
        $joinColumns = NULL;
      }
      $joinColumns = isset($config->model->join->columns) ? $config->model->join->columns : NULL;
      if (isset($joinMethod)) {
        $classname = $joinMethod . 'JoinController';
        require_once(realpath(drupal_get_path('module', 'join_controller')) . "/controller/handler/" . $classname . '.php');
        if (isset($joinColumns)) {
          if (is_array($joinColumns)) {
            if (count($joinColumns) == 0) {
              throw new Exception("Join columns are not defined");
            }
          } else {
            $joinColumns = array($joinColumns);
          }
          $joinController = new $classname($joinColumns);
        } else {
          $joinController = new $classname();
        }
      }

      $joinedRecords = NULL;
      foreach ($config->model->series as $serie) {
        // preparing serie data controller parameters
        $isSerieList = isset($serie->useList) ? $serie->useList : $isList;
        $serieDatasetName = isset($serie->dataset) ? $serie->dataset : $datasetName;

        $serieDatasetName = _update_dataset_datasource($serieDatasetName,$node->widgetConfig->keepOriginalDatasource);
        $serieColumns = array();
        if(isset($serie->columns)){
            foreach($serie->columns as $column){
                array_push($serieColumns, _update_dataset_datasource($column,$node->widgetConfig->keepOriginalDatasource));
            }
        }
        $serieColumns = isset($serieColumns)
            ? (isset($columns) ? array_merge($columns, $serieColumns) : $serieColumns)
            : $columns;
        $serieParameters = $parameters;
        prepare_dataset_parameters($serieParameters, $serie,$node->widgetConfig);

        if(isset($serie->seriesDefaultParameters)){
          foreach($serie->seriesDefaultParameters as $key => $value){
            if (!isset($serieParameters[$key])) {
              $serieParameters[$key] = explode("~",$value);;
            }
          }
        }

        // getting data using data controller
        if(is_array($serieParameters)) {
          foreach ($serieParameters as $key => $value) {
            if (!isset($value)) {
              unset($serieParameters[$key]);
              continue;
            }
            if (!is_array($value)) {
              $serieParameters[$key] = explode("~", $value);
            }
          }
        }

        if(isset($serie->adjustSerieParameters)){
          $serieParameters =  eval($serie->adjustSerieParameters);
        }
        if(isset($serie->adjustSerieColumns)){
          $serieColumns =  eval($serie->adjustSerieColumns);
        }

        // log_debug("Serie parameters");
        // log_debug($serieParameters);
        $serieOrderBy = isset($serie->orderBy) ? $serie->orderBy : $orderBy;
        $serieStartWith = isset($serie->startWith) ? $serie->startWith : $startWith;
        $serieLimit = isset($serie->limit) ? $serie->limit : $limit;

        if(isset($serie->widgetDataLoader)){
            eval($serie->widgetDataLoader);
            $records = $node->data;
        }else {
            $records = $isSerieList
                ? $dataQueryController->queryDataset(
                    $serieDatasetName,
                    $serieColumns, $serieParameters, $serieOrderBy,
                    $serieStartWith, $serieLimit,
                    $resultFormatter)
                : $dataQueryController->queryCube(
                    $serieDatasetName,
                    $serieColumns, $serieParameters, $serieOrderBy,
                    $serieStartWith, $serieLimit,
                    $resultFormatter);
        }
        $node->nodeAdjustedParamaterConfig[] = $parameters;
        // post-processing records
        if (isset($records) && (isset($serie->columnPrefix) || isset($serie->columnSuffix))) {
          foreach ($records as &$record) {
            $updatedRecord = NULL;
            foreach ($record as $columnName => $value) {
              $newColumnName = $columnName;
              if (!isset($joinColumns) || (array_search($columnName, $joinColumns) === FALSE)) {
                  $newColumnName =
                      (isset($serie->columnPrefix) ? $serie->columnPrefix : '')
                      . $columnName
                      . (isset($serie->columnSuffix) ? $serie->columnPrefix : '');
              }
              $updatedRecord[$newColumnName] = $value;
            }
            $record = $updatedRecord;
          }
        }

        if (isset($joinedRecords)) {
            // joining two datasets
            if (isset($joinController)) {
              $sourceConfigurationA = new JoinController_SourceConfiguration($joinedRecords, $config->model->join->columns);
              $sourceConfigurationB = new JoinController_SourceConfiguration($records, $config->model->join->columns);
                $joinedRecords = $joinController->join($sourceConfigurationA, $sourceConfigurationB)->data;
            } else {
                throw new Exception("Join method is not defined for multi-dataset widget");
            }
        } else {
            $joinedRecords = $records;
        }
        }

            $node->data = $joinedRecords;
            //log_debug('Joined records:');
            //log_debug($joinedRecords);
        } else {
            if(!isset($node->widgetConfig->getData) || (isset($node->widgetConfig->getData) && $node->widgetConfig->getData)){
              //Alter Query - For now, this configuration is compatible only for widgets without facets
              if(isset($node->widgetConfig->queryAlterFunction)){
                $query = widget_get_db_query($isList, $datasetName, $columns, $parameters, $orderBy, $startWith, $limit, $resultFormatter);
                $alterFunction = $node->widgetConfig->queryAlterFunction;
                $query = eval($alterFunction);
                $node->data = _checkbook_project_execute_sql_by_data_source($query,Datasource::getCurrent());
              }else {
                $node->data = $isList
                  ? $dataQueryController->queryDataset(
                    $datasetName,
                    $columns, $parameters, $orderBy,
                    $startWith, $limit,
                    $resultFormatter)
                  : $dataQueryController->queryCube(
                    $datasetName,
                    $columns, $parameters, $orderBy,
                    $startWith, $limit,
                    $resultFormatter);
              }
              $node->nodeAdjustedParamaterConfig = $parameters;
            }
          if ($config->getTotalDataCount) {
              LogHelper::log_info('Count for node # '.$node->nid);
              /**
               * Added config setting in the widget json, if set, the count will only consider distinct columns
               */
              if(isset($node->widgetConfig->totalDataColumnConfig) || isset($node->widgetConfig->queryAlterFunction)) {

                  $distinctColumnArray = array();
                  $distinctMappedColumnsArray  = array();

                  if(is_array($node->widgetConfig->totalDataColumnConfig)) {
                      $totalDataColumnConfig = $node->widgetConfig->totalDataColumnConfig;
                      foreach($totalDataColumnConfig as $columnConfig) {
                          $distinctColumnArray[] = $columnConfig->distinctColumn;
                          $distinctMappedColumnsArray[] = $columnConfig->distinctColumnMap;
                      }
                  }
                  else {
                      $distinctColumnArray[] = $node->widgetConfig->totalDataColumnConfig->distinctColumn;
                      $distinctMappedColumnsArray[] = $node->widgetConfig->totalDataColumnConfig->distinctColumnMap;
                  }

                  $distinctColumns = $columns;
                  foreach($distinctColumns as $key => $value) {
                      if(!in_array($value,$distinctColumnArray)) {
                          unset($distinctColumns[$key]);
                      }
                  }

                  $query = widget_get_count_db_query($isList, $datasetName, $distinctColumns, $parameters, $orderBy, $startWith, $limit, $resultFormatter);
                  //Alter Query - For now, this configuration is compatible only for widgets without facets
                  if(isset($node->widgetConfig->queryAlterFunction)) {
                    $alterFunction = $node->widgetConfig->queryAlterFunction;
                    $query = eval($alterFunction);
                  }else{
                    $replace_string = "(SELECT ";
                    $query = substr_replace($query, $replace_string . "DISTINCT ", strpos($query, $replace_string), strlen($replace_string));
                  }

                  $results = _checkbook_project_execute_sql_by_data_source($query,Datasource::getCurrent());
                  $node->totalDataCount = $results[0]['record_count'];
              } else {
                  $node->totalDataCount = $isList
                    ? $dataQueryController->countDatasetRecords(
                      $datasetName, $parameters)
                    : $dataQueryController->countCubeRecords(
                      $datasetName,
                      $columns, $parameters,
                      $resultFormatter);
                  $node->nodeAdjustedParamaterConfig = $parameters;
              }
          }


          if (property_exists($config, 'totalAggregateColumns') && $config->totalAggregateColumns) {
          	foreach($config->totalAggregateColumns as $aggregateColumn){
                $params = $parameters;
                $ds = $datasetName;
                $column = $aggregateColumn;
                //Handle multiple cube joins
                if (strpos($aggregateColumn,'@') !== false) {
                    $col_array = explode("@",$aggregateColumn);
                    $column = $col_array[0];
                    $ds = $col_array[1];
                }
                //Adjust aggregate parameters before sql call
                if(isset($config->adjustTotalAggregateColumnsParameters)){
                    $params =  eval($config->adjustTotalAggregateColumnsParameters);
                }
                $result = $dataQueryController->queryCube($ds,array($column), $params, $orderBy,$startWith, $limit,$resultFormatter);
          		$node->totalAggregateColumns[$aggregateColumn] = $result[0][$column];
          	}
          }

        }

    $node->data = _update_node_data($node->data,$node->widgetConfig->keepOriginalDatasource);
  	if(isset($node->widgetConfig->transformationPHP)){
  		@$node->data = eval($node->widgetConfig->transformationPHP);
  	}
  } catch(Exception $e) {
    // FIXME Commented out printing of $e because it generates 100+ KBs in a log file
    log_error("Error getting data from the controller: \n" . $e->getMessage()/*, $e*/);
    $node->error = $e;
    return;
  }
}


function widget_get_count_db_query($isList, $dataSetName, $columns = NULL, $parameters = NULL, $orderBy = NULL, $startWith = 0, $limit = NULL, ResultFormatter $resultFormatter = NULL){
    //Since we are disabling execution mode below, need to make sure meta model is loaded.
    data_controller_get_metamodel();
    $executionMode = AbstractSQLDataSourceHandler::$STATEMENT_EXECUTION_MODE;
    try {
      AbstractSQLDataSourceHandler::$STATEMENT_EXECUTION_MODE = AbstractSQLDataSourceHandler::STATEMENT_EXECUTION_MODE__IGNORE;
      StatementLogMessageKeeper::reset();

      $controller = data_controller_get_instance();
      if($isList){
          $controller->countDatasetRecords($dataSetName,$parameters);
      }else{
          $controller->countCubeRecords($dataSetName,$columns, $parameters,$resultFormatter);
      }
      $sqlQuery = $isList ? StatementLogMessageKeeper::$statements['*.count'][0] : StatementLogMessageKeeper::$statements['*.count'][0];
    }
    catch (Exception $e) {
      AbstractSQLDataSourceHandler::$STATEMENT_EXECUTION_MODE = $executionMode;
      throw $e;
    }
    AbstractSQLDataSourceHandler::$STATEMENT_EXECUTION_MODE = $executionMode;
    return $sqlQuery;
}


function widget_get_db_query($isList, $dataSetName, $columns = NULL, $parameters = NULL, $orderBy = NULL, $startWith = 0, $limit = NULL, ResultFormatter $resultFormatter = NULL){
    //Since we are disabling execution mode below, need to make sure meta model is loaded.
    data_controller_get_metamodel();
    $executionMode = AbstractSQLDataSourceHandler::$STATEMENT_EXECUTION_MODE;
    try {
      AbstractSQLDataSourceHandler::$STATEMENT_EXECUTION_MODE = AbstractSQLDataSourceHandler::STATEMENT_EXECUTION_MODE__IGNORE;
      StatementLogMessageKeeper::reset();

      $controller = data_controller_get_instance();
      if($isList){
        $controller->queryDataset($dataSetName, $columns, $parameters, $orderBy, $startWith, $limit, $resultFormatter);
      }else{
        $controller->queryCube($dataSetName, $columns, $parameters, $orderBy, $startWith, $limit, $resultFormatter);
      }
      $sqlQuery = $isList ? StatementLogMessageKeeper::$statements['dataset.query'][0] : StatementLogMessageKeeper::$statements['cube.query'][0];
    }
    catch (Exception $e) {
      AbstractSQLDataSourceHandler::$STATEMENT_EXECUTION_MODE = $executionMode;
      throw $e;
    }
    AbstractSQLDataSourceHandler::$STATEMENT_EXECUTION_MODE = $executionMode;
    return $sqlQuery;
}

function widget_data(&$node) {
  $config = $node->widgetConfig;
  $requestParams = $config->requestParams;
  $originalReqParams = $config->originalRequestParams;
  if(isset($requestParams)) {
    foreach ($requestParams as $key => $value) {
      $requestParams[$key] = pg_escape_string(htmlspecialchars_decode($value));
    }
  }

  if(isset($requestParams)) {
    $config->requestParams = $requestParams;
  }

  if(isset($originalReqParams)) {
    foreach ($originalReqParams as $key => $value) {
      $originalReqParams[$key] = pg_escape_string(htmlspecialchars_decode($value));
    }
    $config->originalRequestParams = $originalReqParams;
  }

  $resultFormatter = new SpecialCharacterResultFormatter(NULL,new ArrayResultFormatter());
  if($node->widgetConfig->exportData){
    //During data export we do not want to escape data.
    //If really required check for another formatter
    $resultFormatter = null;
  }

  if(isset($node->widgetConfig->widgetDataLoader)){
    eval($node->widgetConfig->widgetDataLoader);
  }
  elseif (isset($node->widgetConfig->dataset) || isset($node->widgetConfig->model)) {
    LogHelper::log_notice("Loading widget node # ".$node->nid);
    load_widget_data($node, $resultFormatter);
  }

	if (isset($node->widgetConfig->flattenRows)) {
		//convert grouped results into flattened result array
		if (isset($node->data)) {
			$flattenedData = array();
			foreach ($node->data as $rowKey => $row) {
				$flattenedRow = array();
				//put group by column into flattened row
				$flattenedRow[$node->widgetConfig->flattenRows->groupByColumn] = $rowKey;

				foreach ($row as $innerRow) {
					//calculate discriminator value
					$discriminatorValue = $innerRow[$node->widgetConfig->flattenRows->discriminatorColumn];
					//put all other columns into flattened array with discriminator value prepended
					foreach ($innerRow as $colName => $colVal) {
						if (($colName == $node->widgetConfig->flattenRows->groupByColumn) || ($colName == $node->widgetConfig->flattenRows->discriminatorColumn)) {
							continue;
						}
						$flattenedRow[$discriminatorValue . '_' . $colName] = $colVal;
					}
				}
				$flattenedData[] = $flattenedRow;
			}
			$node->data = $flattenedData;
		}

	}

	//drupal_set_message('<pre>$$$node->data'. print_r($node->data, TRUE) . '</pre>');
	if (isset($node->widgetConfig->derivedColumns)) {

    /**
     * TODO: DEBUG this
     */
		foreach ($node->widgetConfig->derivedColumns as $derivedColumnName => $derivedColumnDefinition) {
		    $flag = property_exists($derivedColumnDefinition, 'visibility_flag') ? $derivedColumnDefinition->visibility_flag : null;
			$visibility_flag = check_node_flag_visibilty($flag, $node);
			if (isset($node->data) && is_array($node->data) && $visibility_flag) {
    //log_debug($node->data);
				foreach ($node->data as $rowKey => $row) {
          /**
           * TODO: DEBUG this
           */
					$result = calculateDerivedCell($row, $node->data, $derivedColumnDefinition, $node);
					$node->data[$rowKey][$derivedColumnName] = $result;
					if (isset($derivedColumnDefinition->saveInConfig)) {
						$node->widgetConfig->$derivedColumnName = $result;
					}
				}
			}
		}
	}
}


/*
 * check if a given flag is set on the node. -flag_name with set visibilty to false, flag_name and empty value will set visibility to true.
 */

function check_node_flag_visibilty($flag,$node){
	$visibility_flag = true;
	if(isset($flag)){
		if($flag[0] == "-"){
			$visibility_flag_name = substr($flag,1);
			$visibility_flag = (!isset($visibility_flag_name) or $node->$visibility_flag_name == true   ) ? false : true;
		}else{
			$visibility_flag_name = $flag;
			$visibility_flag = (!isset($visibility_flag_name) or $node->$visibility_flag_name == true   ) ? true : false;
		}
	}
	return $visibility_flag;
}

function calculateDerivedCell($row, $fulldata, $derivedColumnDefinition,$node) {
  if (empty($derivedColumnDefinition->type)) {
    $derivedColumnDefinition->type = 'default';
  }
	switch($derivedColumnDefinition->type) {
    default:
      $expression = $derivedColumnDefinition->expression;
      $result = eval("return $expression;");
      return $result;
  }
}

function widget_config($node) {
	//save
	if (isset($node->widgetConfig->uid)) {
		$savedUid = $node->widgetConfig->uid;
	}
	if (isset($node->widgetConfig->additionalParameters)) {
		$savedAdditionalParameters = $node->widgetConfig->additionalParameters;
	}

	$FUNCTION_START = '<function>';
	$FUNCTION_END = '</function>';
	$PLACEHOLDER_START = '"function":"';
	$PLACEHOLDER_END = '"';
	$FUNCTION_DELIMITER = '##';
	$FUNCTIONNAME_DELIMITER = '^^';

	$functionStart = strpos($node->widget_json,$FUNCTION_START);
	if ($functionStart != false) {
		$functionEnd = strpos($node->widget_json, $FUNCTION_END);
		$functions = substr($node->widget_json, $functionStart+ drupal_strlen($FUNCTION_START), $functionEnd - $functionStart - drupal_strlen($FUNCTION_START));
		$funcList = explode($FUNCTION_DELIMITER, $functions);
		$functionMap = array();
		foreach ($funcList as $jsFunction) {
			$keyVal = explode($FUNCTIONNAME_DELIMITER, $jsFunction);
			$functionMap[str_replace("\r\n", "", $keyVal[0])] = $keyVal[1];
		}
		unset($jsFunction);
		$node->jsFunctions = $functionMap;
		$json = str_replace($FUNCTION_START.$functions.$FUNCTION_END, '', $node->widget_json);

	} else {
		$json = $node->widget_json;
	}
	$converter = new Json2PHPObject();
	$node->widgetConfig = $converter->convert($json);

	//restore
	if (isset($savedUid)) {
		$node->widgetConfig->uid = $savedUid;
	}
	if (isset($savedAdditionalParameters)) {
		$node->widgetConfig->additionalParameters = $savedAdditionalParameters;
	}
	$node->widgetConfig = widget_merge_parent_node_config($node);
	return $node->widgetConfig;
}

function widget_merge_parent_node_config($node){
  $parent_nid = isset($node->widgetConfig->parentNid) ? $node->widgetConfig->parentNid : null;
  if($parent_nid > 0){
    $parent_node = node_load($parent_nid);
    widget_config($parent_node);
    return widget_merge_config($parent_node->widgetConfig, $node->widgetConfig);
  }else{
    return $node->widgetConfig;
  }
}

function widget_merge_config($parent_config, $child_config){
  $child_config->cleanURLParameters = $parent_config->cleanURLParameters;
  $child_config->cleanURLParameters[] = $child_config->autocompleteParamName;
  $child_config->paramTypeConfig = $parent_config->paramTypeConfig;
  $child_config->preProcessConfiguration = $parent_config->preProcessConfiguration;
  if(isset($child_config->widgetConfig->adjustFacetOptions)){
    eval($child_config->widgetConfig->adjustFacetOptions);
  }
  $autocompleteParamName = $child_config->autocompleteParamName;
  if(isset($autocompleteParamName)){
    $child_config->paramTypeConfig->$autocompleteParamName = "autocomplete";
  }
  $urlParameterName = $child_config->urlParameterName;

  $paramNameType = $child_config->urlParameterNameType ?? 'ne';
  $child_config->paramTypeConfig->$urlParameterName = match ($paramNameType) {
    'eqtext' => "neqignorecase",
    'capitalize' => "necapitalize",
    default => "ne",
  };

  if (isset($child_config->urlParamMap) && $child_config->urlParamMap) {
    foreach ($child_config->urlParamMap as $key => $value) {
      $parent_config->urlParamMap->$key = $value;
    }
  }

  $child_config->urlParamMap = $parent_config->urlParamMap;
  $autocompleteParamName = $child_config->autocompleteParamName;
  if(isset($autocompleteParamName)){
    $child_config->urlParamMap->$autocompleteParamName = $child_config->autocompleteField;
  }

  if($child_config->urlParameterType == "rangeid" || $child_config->urlParameterType == "rangeid2" || $child_config->urlParameterType == "rangeid3"){
    if(($key = array_search($urlParameterName, $child_config->cleanURLParameters)) !== false) {
      unset($child_config->cleanURLParameters[$key]);
    }
  }

  if(!isset($child_config->dataset)){
    $child_config->dataset = $parent_config->dataset;
  }
  if(!isset($child_config->logicalOrColumns)){
    $child_config->logicalOrColumns = $parent_config->logicalOrColumns;
  }
  if(!isset($child_config->sortSourceByNull)){
      $child_config->sortSourceByNull= $parent_config->sortSourceByNull;
  }

  return (object) $child_config;
}


/**
 * Returns JSON file after merging in the js functions
 * @param $node
 * @param $phpArray
 * @return false|mixed|string
 */
function widget_mergeJSFunctions($node, $phpArray) {
	$PLACEHOLDER_START = '"function":"';
	$PLACEHOLDER_END = '"';

	$json = json_encode($phpArray);
	if (!$json) {
    $error = json_last_error_msg();
    LogHelper::log_warn('Could not encode json:: '.$error);
  }

	if (isset($node->jsFunctions)) {
		foreach ($node->jsFunctions as $key => $value) {
			$replace = $PLACEHOLDER_START. trim($key) . $PLACEHOLDER_END;
			$json = str_replace($replace, $value, $json);
		}
	}
	return $json;
}
/***************************************/
/* Functions to support same widget    */
/* on the same page                    */
/***************************************/

function widget_set_uid(&$node, $uid) {
	$node->widgetConfig->uid = $uid;
}

function widget_add_additional_parameters(&$node, $parameters) {
	$node->widgetConfig->additionalParameters = $parameters;
}

/***************************************/
/* Common naming functions             */
/***************************************/

function widget_unique_identifier($node) {
	$uid = $node->nid;
	if (isset($node->widgetConfig->uid)) {
		$uid .= "_" . $node->widgetConfig->uid;
	}
	return $uid;
}

function widget_get_div_name($node) {
	return "widgetdiv" . widget_unique_identifier($node);
}

function widget_get_widget_callback_function_name($node) {
	return "widget" . widget_unique_identifier($node) . "Callback";
}

function widget_get_updated_data_function_name($node) {
	return "widget" . widget_unique_identifier($node) . "UpdateData";
}

function widget_get_widget_exclude_params_name($node) {
	return "widget" . widget_unique_identifier($node) . "ExcludeParams";
}

/***************************************/
/* Content building utility functions  */
/***************************************/

function widget_callback_function($node) {
	$output  = "function " . widget_get_widget_callback_function_name($node) . "(event) {\n";
	$output .= widget_get_updated_data_function_name($node) . "();\n";
	$output .= $node->widgetConfig->customCallbackJavascript . "\n";
	$output .= "}\n";
	return $output;
}

function widget_attach_to_widget_controller($node) {
	$output = "widgetCoordinator.attach(" . widget_get_widget_callback_function_name($node) . ");\n";
	return $output;
}

function widget_define_exclude_params($node) {
	$output = "var " . widget_get_widget_exclude_params_name($node) . " = [";
	if (isset($node->widgetConfig->excludeParams)) {
		$i = 0;
		foreach ($node->widgetConfig->excludeParams as $param) {
			if ($i != 0) {
				$output .= ", ";
			}
			$output .= "'" . $param . "'";
			$i++;
		}
	}
	$output .= "];\n";
	return $output;
}

function _replaceSpecialCharactersDecode($string){
	$string = str_replace('__','/',$string);
    return str_replace('^^','.',$string);
}

function _update_node_data($data,$keepOriginalDatasource = false){
	if($keepOriginalDatasource == true){
		return $data;
	}
    $returnData = array();
	  if ($data){
      foreach((Array)$data as $key=>$value){
        $arrayValues = array();
        foreach((Array)$value as $a=>$b){
          $a = str_replace('@checkbook_oge:',"@checkbook:",$a);
          $a = str_replace('@checkbook_nycha:',"@checkbook:",$a);
          $arrayValues[$a] = $b;
        }
        $returnData[$key] = $arrayValues;
      }
    }

    return $returnData;
}

function _update_columns_by_datasource($node_columns, $datasource_mapping = null, $keepOriginalDatasource= false){
	if($keepOriginalDatasource == true){
		return $node_columns;
	}
  $columns = array();
  $database = RequestUtilities::get('datasource');
  $datasource_mapping = ($datasource_mapping != null) ? get_object_vars($datasource_mapping) : null;
  if (isset($node_columns) && $node_columns) {
    foreach($node_columns as $column){
      if($datasource_mapping == null){
        array_push($columns, _update_dataset_datasource($column));
      }else{
        if(!array_key_exists($column, $datasource_mapping)){
          array_push($columns, _update_dataset_datasource($column));
        }
        else if(array_key_exists($column, $datasource_mapping) && $datasource_mapping[$column] == $database){
          array_push($columns, _update_dataset_datasource($column));
        }
      }
    }
  }
  return $columns;
}

function _widget_build_sql_condition($column, $value){
	$values_array = explode('~',$value);
	if(count($values_array) > 1){
		return  $column . ' in ' . '(\'' . implode('\',\'', $values_array) . '\')';
	}else{
		return  $column . '=' . '\'' . $value . '\'';
	}
}
function _widget_build_sql_not_condition($column, $value){
  $values_array = explode('~',$value);
  if(count($values_array) > 1){
    return  $column . ' in ' . '(\'' . implode('\',\'', $values_array) . '\')';
  }else{
    return  $column . '!=' . '\'' . $value . '\'';
  }
}

function _widget_build_sql_add_null($column, $value){
  $values_array = explode('~',$value);
  if(count($values_array) > 1){
    return  $column . ' in ' . '(\'' . implode('\',\'', $values_array) . '\')';
  }else{
    return   '\'' . $value . '\''. ' AS '. $column;
  }
}


